import { defineComponent, shallowRef, computed, ref, onMounted, nextTick, onBeforeUnmount, openBlock, createElementBlock, createElementVNode, normalizeStyle, renderSlot, normalizeClass, createCommentVNode } from "vue";
import { n as noop } from "../../../vendor.js";
import { g as getWindow } from "../../utils/ssr.js";
import { u as useComponentPresetProp } from "../../composables/useComponentPreset.js";
import { u as useNumericProp } from "../../composables/useNumericProp.js";
import { u as useEventsHandlerWithThrottle, h as handleThrottledEvent, g as getWindowHeight } from "./VaAffix-utils.js";
const _sfc_main = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaAffix"
  },
  __name: "VaAffix",
  props: {
    ...useComponentPresetProp,
    offsetTop: { type: [Number, String], default: void 0 },
    offsetBottom: { type: [Number, String], default: void 0 },
    target: { type: [Object, Function], default: getWindow }
  },
  emits: ["change"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const element = shallowRef();
    const getTargetElement = () => typeof props.target === "function" ? props.target() : props.target;
    const isAffixed = computed(() => state.value.isTopAffixed || state.value.isBottomAffixed);
    const state = ref({
      isTopAffixed: false,
      isBottomAffixed: false
    });
    const getState = () => state.value;
    const setState = (newState) => {
      state.value = newState;
      emit("change", isAffixed);
    };
    const offsetTopComputed = useNumericProp("offsetTop");
    const offsetBottomComputed = useNumericProp("offsetBottom");
    const calculateTop = () => {
      const target = getTargetElement();
      if (!target) {
        return 0;
      }
      if (offsetTopComputed.value === void 0) {
        return;
      }
      if (!(target instanceof Window)) {
        const { top } = target.getBoundingClientRect();
        return top + offsetTopComputed.value;
      }
      return offsetTopComputed.value;
    };
    const calculateBottom = () => {
      const target = getTargetElement();
      if (!target) {
        return 0;
      }
      if (offsetBottomComputed.value === void 0) {
        return;
      }
      if (!(target instanceof Window)) {
        const { bottom } = target.getBoundingClientRect();
        const { borderTopWidth, borderBottomWidth } = getComputedStyle(target);
        const { offsetHeight, clientHeight } = target;
        const scrollBarHeight = offsetHeight - clientHeight - parseInt(borderTopWidth) - parseInt(borderBottomWidth);
        return getWindowHeight() - (bottom - offsetBottomComputed.value) + scrollBarHeight;
      }
      return offsetBottomComputed.value;
    };
    const convertToPixels = (calculate) => {
      const result = calculate();
      return result === void 0 ? void 0 : `${result}px`;
    };
    const computedClass = computed(() => [{ "va-affix--affixed": isAffixed }]);
    const computedStyle = computed(() => ({
      top: state.value.isTopAffixed ? convertToPixels(calculateTop) : void 0,
      bottom: state.value.isBottomAffixed ? convertToPixels(calculateBottom) : void 0,
      width: `${state.value.width}px`
    }));
    const initialPosition = ref();
    const throttledEventHandler = (eventName, event) => {
      const context = {
        ...props,
        offsetTop: offsetTopComputed.value,
        offsetBottom: offsetBottomComputed.value,
        initialPosition: initialPosition.value,
        element: element.value,
        target: getTargetElement(),
        setState,
        getState
      };
      if (!eventName || eventName === "resize") {
        handleThrottledEvent(eventName, context);
      } else if (event && event.target) {
        const target = getTargetElement();
        if (target === event.target || target instanceof Window) {
          handleThrottledEvent(eventName, context);
        } else {
          setState({
            isBottomAffixed: false,
            isTopAffixed: false
          });
        }
      }
    };
    let clearEventListeners = noop;
    onMounted(() => {
      var _a;
      initialPosition.value = (_a = element.value) == null ? void 0 : _a.getBoundingClientRect();
      const events = ["scroll", "resize"];
      clearEventListeners = useEventsHandlerWithThrottle(events, {
        handler: throttledEventHandler
      });
      nextTick(() => {
        throttledEventHandler(null);
      });
    });
    onBeforeUnmount(clearEventListeners);
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        ref_key: "element",
        ref: element,
        class: "va-affix"
      }, [
        createElementVNode("div", {
          style: normalizeStyle({ visibility: isAffixed.value ? "hidden" : "inherit" })
        }, [
          renderSlot(_ctx.$slots, "default")
        ], 4),
        isAffixed.value ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass(computedClass.value),
          style: normalizeStyle(computedStyle.value)
        }, [
          renderSlot(_ctx.$slots, "default")
        ], 6)) : createCommentVNode("", true)
      ], 512);
    };
  }
});
export {
  _sfc_main as _
};

import '../../../VaAffix.css';
//# sourceMappingURL=VaAffix.vue_vue_type_script_setup_true_lang.js.map
