import { defineComponent, ref, computed, onBeforeMount, onBeforeUnmount, watch, useSlots, openBlock, createBlock, unref, mergeProps, withCtx, withDirectives, createElementVNode, renderSlot, createCommentVNode, createElementBlock, vShow, createVNode, nextTick } from "vue";
import { p as pick } from "../../../vendor.js";
import { V as VaAspectRatio } from "../va-aspect-ratio/index.js";
import { V as VaFallback } from "../va-fallback/index.js";
import { u as useNativeImgAttributesProps, a as useNativeImgAttributes } from "./hooks/useNativeImgAttributes.js";
import { u as useIntersectionObserver } from "../../composables/useIntersectionObserver.js";
import { e as extractComponentProps } from "../../utils/component-options/extract-component-options.js";
import { u as useComponentPresetProp } from "../../composables/useComponentPreset.js";
import { u as useIsMounted } from "../../composables/useIsMounted.js";
import { f as filterComponentProps } from "../../utils/component-options/filter-props.js";
import { u as useGlobalConfig } from "../../composables/useGlobalConfig.js";
const _hoisted_1 = ["aria-busy"];
const _hoisted_2 = {
  key: 0,
  class: "va-image__overlay"
};
const _hoisted_3 = {
  key: 1,
  class: "va-image__error"
};
const _hoisted_4 = {
  key: 2,
  class: "va-image__loader"
};
const _hoisted_5 = {
  key: 3,
  class: "va-image__placeholder"
};
const _hoisted_6 = ["src"];
const VaFallbackProps = extractComponentProps(VaFallback);
const _sfc_main = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaImage"
  },
  __name: "VaImage",
  props: {
    ...useComponentPresetProp,
    ...useNativeImgAttributesProps,
    ...VaFallbackProps,
    ratio: {
      type: [Number, String],
      default: "auto",
      validator: (v) => {
        if (typeof v === "number") {
          return v > 0;
        }
        return v === "auto";
      }
    },
    fit: {
      type: String,
      default: "cover"
    },
    maxWidth: {
      type: [Number, String],
      default: 0,
      validator: (v) => Number(v) >= 0
    },
    lazy: { type: Boolean, default: false },
    placeholderSrc: { type: String, default: "" }
  },
  emits: ["loaded", "error", "fallback"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const root = ref();
    const image = ref();
    const renderedImage = ref();
    const currentImage = computed(() => renderedImage.value || props.src);
    const imgWidth = ref(1);
    const imgHeight = ref(1);
    const isLoading = ref(false);
    const isError = ref(false);
    const handleLoad = () => {
      var _a;
      isLoading.value = true;
      if (!isReadyForLoad.value) {
        return;
      }
      isLoading.value = false;
      renderedImage.value = (_a = image.value) == null ? void 0 : _a.currentSrc;
      getImgSizes();
      emit("loaded", currentImage.value);
    };
    const handleError = (err) => {
      isError.value = true;
      isLoading.value = false;
      emit("error", err || currentImage.value);
    };
    const isIntersecting = ref(false);
    const handleIntersection = (entries, observer) => {
      entries.forEach((entry) => {
        if (!entry.isIntersecting) {
          return;
        }
        isIntersecting.value = true;
        init();
        observer.disconnect();
      });
    };
    const { isIntersectionDisabled } = useIntersectionObserver(handleIntersection, void 0, root, props.lazy);
    const isReadyForLoad = computed(() => isIntersectionDisabled.value || isIntersecting.value);
    const isMounted = useIsMounted();
    const isReadyForRender = computed(() => !props.lazy || props.lazy && isMounted.value && isReadyForLoad.value);
    const init = () => {
      if (!props.src || isLoading.value && isIntersectionDisabled.value || !isReadyForLoad.value) {
        return;
      }
      isLoading.value = true;
      isError.value = false;
      nextTick(() => {
        var _a;
        if (!((_a = image.value) == null ? void 0 : _a.complete)) {
          return;
        }
        if (!image.value.naturalWidth) {
          handleError();
          return;
        }
        handleLoad();
      });
    };
    let timer;
    const getImgSizes = () => {
      clearTimeout(timer);
      if (isLoading.value) {
        timer = window.setTimeout(getImgSizes, 100);
      }
      const { naturalHeight, naturalWidth } = image.value || {};
      if (naturalHeight && naturalWidth) {
        imgWidth.value = naturalHeight;
        imgHeight.value = naturalWidth;
      }
    };
    onBeforeMount(init);
    onBeforeUnmount(() => clearTimeout(timer));
    watch(() => props.src, init);
    const slots = useSlots();
    const isPlaceholderPassed = computed(() => {
      var _a;
      return ((_a = slots == null ? void 0 : slots.placeholder) == null ? void 0 : _a.call(slots)) || props.placeholderSrc;
    });
    const isLoaderShown = computed(() => {
      var _a;
      return isLoading.value && !((_a = slots == null ? void 0 : slots.loader) == null ? void 0 : _a.call(slots));
    });
    const isErrorShown = computed(() => {
      var _a;
      return isError.value && (!((_a = slots == null ? void 0 : slots.error) == null ? void 0 : _a.call(slots)) && !isAnyFallbackPassed.value);
    });
    const isPlaceholderShown = computed(() => (isLoaderShown.value || isErrorShown.value) && isPlaceholderPassed.value);
    const isSuccessfullyLoaded = computed(() => !(isLoading.value || isError.value));
    const imgAttributesComputed = useNativeImgAttributes(props);
    const aspectRationAttributesComputed = computed(() => ({
      ...pick(props, ["ratio", "maxWidth"]),
      contentWidth: imgWidth.value,
      contentHeight: imgHeight.value
    }));
    const fallbackProps = filterComponentProps(VaFallbackProps);
    const checkObjectNonEmptyValues = (obj) => !!Object.values(obj || {}).filter((prop) => prop).length;
    const hasFallbackGlobalConfig = computed(() => {
      var _a, _b, _c, _d;
      return checkObjectNonEmptyValues((_d = (_c = (_b = (_a = useGlobalConfig()) == null ? void 0 : _a.globalConfig) == null ? void 0 : _b.value) == null ? void 0 : _c.components) == null ? void 0 : _d.VaFallback);
    });
    const isAnyFallbackPassed = computed(() => checkObjectNonEmptyValues(fallbackProps.value) || hasFallbackGlobalConfig.value);
    const fitComputed = computed(() => props.fit);
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(VaAspectRatio), mergeProps({
        ref_key: "root",
        ref: root,
        class: "va-image"
      }, aspectRationAttributesComputed.value, {
        style: `--va-fit-computed: ${String(fitComputed.value)}`
      }), {
        default: withCtx(() => [
          withDirectives(createElementVNode("picture", {
            class: "va-image__content",
            "aria-busy": isLoading.value
          }, [
            _ctx.$slots.sources ? renderSlot(_ctx.$slots, "sources", { key: 0 }) : createCommentVNode("", true),
            isReadyForRender.value ? (openBlock(), createElementBlock("img", mergeProps({
              key: 1,
              ref_key: "image",
              ref: image
            }, unref(imgAttributesComputed), {
              onError: handleError,
              onLoad: handleLoad
            }), null, 16)) : createCommentVNode("", true)
          ], 8, _hoisted_1), [
            [vShow, isSuccessfullyLoaded.value]
          ]),
          _ctx.$slots.default && isSuccessfullyLoaded.value ? (openBlock(), createElementBlock("div", _hoisted_2, [
            renderSlot(_ctx.$slots, "default")
          ])) : createCommentVNode("", true),
          isError.value && (_ctx.$slots.error || isAnyFallbackPassed.value) ? (openBlock(), createElementBlock("div", _hoisted_3, [
            renderSlot(_ctx.$slots, "error", {}, () => [
              createVNode(unref(VaFallback), mergeProps(unref(fallbackProps), {
                onFallback: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("fallback"))
              }), null, 16)
            ])
          ])) : createCommentVNode("", true),
          isLoading.value && _ctx.$slots.loader ? (openBlock(), createElementBlock("div", _hoisted_4, [
            renderSlot(_ctx.$slots, "loader")
          ])) : createCommentVNode("", true),
          isPlaceholderShown.value ? (openBlock(), createElementBlock("div", _hoisted_5, [
            renderSlot(_ctx.$slots, "placeholder", {}, () => [
              _ctx.$props.placeholderSrc ? (openBlock(), createElementBlock("img", {
                key: 0,
                src: _ctx.$props.placeholderSrc,
                alt: ""
              }, null, 8, _hoisted_6)) : createCommentVNode("", true)
            ])
          ])) : createCommentVNode("", true)
        ]),
        _: 3
      }, 16, ["style"]);
    };
  }
});
export {
  _sfc_main as _
};

import '../../../VaImage.css';
//# sourceMappingURL=VaImage.vue_vue_type_script_setup_true_lang.js.map
