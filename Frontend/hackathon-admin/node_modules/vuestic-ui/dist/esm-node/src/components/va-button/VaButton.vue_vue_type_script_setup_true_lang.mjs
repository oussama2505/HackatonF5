import { defineComponent, computed, toRefs, shallowRef, openBlock, createBlock, resolveDynamicComponent, unref, mergeProps, withCtx, createElementVNode, normalizeClass, renderSlot, normalizeProps, guardReactiveProps, createCommentVNode, createVNode } from "vue";
import { p as pick } from "../../../vendor.mjs";
import { u as useButtonBackground } from "./hooks/useButtonBackground.mjs";
import { u as useButtonAttributes } from "./hooks/useButtonAttributes.mjs";
import { u as useButtonTextColor } from "./hooks/useButtonTextColor.mjs";
import { V as VaIcon } from "../va-icon/index.mjs";
import { V as VaProgressCircle } from "../va-progress-circle/index.mjs";
import { u as useHoverStyleProps } from "../../composables/useHoverStyle.mjs";
import { u as usePressedStyleProps } from "../../composables/usePressedStyle.mjs";
import { u as useLoadingProps } from "../../composables/useLoading.mjs";
import { u as useRouterLinkProps, a as useRouterLink } from "../../composables/useRouterLink.mjs";
import { u as useFocus } from "../../composables/useFocus.mjs";
import { u as useHover } from "../../composables/useHover.mjs";
import { u as usePressed } from "../../composables/usePressed.mjs";
import { u as useSlotPassed } from "../../composables/useSlotPassed.mjs";
import { u as useComponentPresetProp } from "../../composables/useComponentPreset.mjs";
import { u as useSizeProps, a as useSize } from "../../composables/useSize.mjs";
import { u as useColors } from "../../composables/useColors.mjs";
import { u as useNumericProp } from "../../composables/useNumericProp.mjs";
import { u as useBem } from "../../composables/useBem.mjs";
import { u as useTextColor } from "../../composables/useTextColor.mjs";
const _sfc_main = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaButton"
  },
  __name: "VaButton",
  props: {
    ...useComponentPresetProp,
    ...useSizeProps,
    ...useHoverStyleProps,
    ...usePressedStyleProps,
    ...useLoadingProps,
    ...useRouterLinkProps,
    tag: { type: String, default: "button" },
    type: { type: String, default: "button" },
    block: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    color: { type: String, default: "primary" },
    textColor: { type: String, default: "" },
    textOpacity: { type: [Number, String], default: 1 },
    backgroundOpacity: { type: [Number, String], default: 1 },
    borderColor: { type: String, default: "" },
    // only for filled bg state
    gradient: { type: Boolean, default: false },
    plain: { type: Boolean, default: false },
    round: { type: Boolean, default: false },
    size: {
      type: String,
      default: "medium",
      validator: (v) => ["small", "medium", "large"].includes(v)
    },
    icon: { type: String, default: "" },
    iconRight: { type: String, default: "" },
    iconColor: { type: String, default: "" }
  },
  setup(__props, { expose: __expose }) {
    const props = __props;
    const { getColor } = useColors();
    const colorComputed = computed(() => getColor(props.color));
    const { sizeComputed } = useSize(props);
    const iconSizeComputed = computed(() => {
      const size = /([0-9]*)(px)/.exec(sizeComputed.value);
      return size ? `${+size[1] / 2}${size[2]}` : sizeComputed.value;
    });
    const { tagComputed } = useRouterLink(props);
    const attributesComputed = useButtonAttributes(props);
    const { disabled } = toRefs(props);
    const button = shallowRef();
    const { focus, blur } = useFocus(button);
    const { isHovered } = useHover(button, disabled);
    const { isPressed } = usePressed(button);
    const iconColorComputed = computed(() => props.iconColor ? getColor(props.iconColor) : textColorComputed.value);
    const iconAttributesComputed = computed(() => ({
      color: iconColorComputed.value,
      size: props.size
    }));
    const wrapperClassComputed = computed(() => ({ "va-button__content--loading": props.loading }));
    const isSlotContentPassed = useSlotPassed();
    const isOneIcon = computed(() => !!(props.iconRight && !props.icon || !props.iconRight && props.icon));
    const isOnlyIcon = computed(() => !isSlotContentPassed.value && isOneIcon.value);
    const textOpacityComputed = useNumericProp("textOpacity");
    const backgroundOpacityComputed = useNumericProp("backgroundOpacity");
    const computedClass = useBem("va-button", () => ({
      ...pick(props, ["disabled", "block", "loading", "round", "plain"]),
      small: props.size === "small",
      normal: !props.size || props.size === "medium",
      large: props.size === "large",
      opacity: textOpacityComputed.value < 1,
      bordered: !!props.borderColor,
      iconOnly: isOnlyIcon.value,
      leftIcon: !isOnlyIcon.value && !!props.icon && !props.iconRight,
      rightIcon: !isOnlyIcon.value && !props.icon && !!props.iconRight
    }));
    const isTransparentBg = computed(() => props.plain || backgroundOpacityComputed.value < 0.5);
    const { textColorComputed } = useTextColor(colorComputed, isTransparentBg);
    const {
      backgroundColor,
      backgroundColorOpacity,
      backgroundMaskOpacity,
      backgroundMaskColor
    } = useButtonBackground(colorComputed, isPressed, isHovered);
    const contentColorComputed = useButtonTextColor(textColorComputed, colorComputed, isPressed, isHovered);
    const computedStyle = computed(() => ({
      borderColor: props.borderColor ? getColor(props.borderColor) : "transparent",
      ...contentColorComputed.value
    }));
    __expose({
      focus,
      blur
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(resolveDynamicComponent(unref(tagComputed)), mergeProps({
        ref_key: "button",
        ref: button,
        class: ["va-button", unref(computedClass)],
        style: [computedStyle.value, `--va-background-color: ${String(unref(backgroundColor))};--va-background-color-opacity: ${String(unref(backgroundColorOpacity))};--va-background-mask-color: ${String(unref(backgroundMaskColor))};--va-background-mask-opacity: ${String(unref(backgroundMaskOpacity))}`]
      }, unref(attributesComputed)), {
        default: withCtx(() => [
          createElementVNode("span", {
            class: normalizeClass(["va-button__content", wrapperClassComputed.value])
          }, [
            renderSlot(_ctx.$slots, "prepend", normalizeProps(guardReactiveProps({ icon: __props.icon, iconAttributes: iconAttributesComputed.value })), () => [
              __props.icon ? (openBlock(), createBlock(unref(VaIcon), mergeProps({
                key: 0,
                class: "va-button__left-icon",
                name: __props.icon
              }, iconAttributesComputed.value), null, 16, ["name"])) : createCommentVNode("", true)
            ]),
            renderSlot(_ctx.$slots, "default"),
            renderSlot(_ctx.$slots, "append", normalizeProps(guardReactiveProps({ icon: __props.iconRight, iconAttributes: iconAttributesComputed.value })), () => [
              __props.iconRight ? (openBlock(), createBlock(unref(VaIcon), mergeProps({
                key: 0,
                class: "va-button__right-icon",
                name: __props.iconRight
              }, iconAttributesComputed.value), null, 16, ["name"])) : createCommentVNode("", true)
            ])
          ], 2),
          _ctx.loading ? renderSlot(_ctx.$slots, "loading", normalizeProps(mergeProps({ key: 0 }, {
            size: iconSizeComputed.value,
            color: unref(textColorComputed)
          })), () => [
            createVNode(unref(VaProgressCircle), {
              class: "va-button__loader",
              size: iconSizeComputed.value,
              color: unref(textColorComputed),
              thickness: 0.15,
              indeterminate: ""
            }, null, 8, ["size", "color"])
          ]) : createCommentVNode("", true)
        ]),
        _: 3
      }, 16, ["class", "style"]);
    };
  }
});
export {
  _sfc_main as _
};
//# sourceMappingURL=VaButton.vue_vue_type_script_setup_true_lang.mjs.map
