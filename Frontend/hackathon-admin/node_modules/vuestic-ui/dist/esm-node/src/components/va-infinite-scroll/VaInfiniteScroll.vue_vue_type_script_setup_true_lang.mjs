import { defineComponent, shallowRef, ref, computed, watch, openBlock, createBlock, resolveDynamicComponent, normalizeClass, withCtx, renderSlot, createElementVNode, createVNode, unref, createCommentVNode } from "vue";
import { d as debounce } from "../../../vendor.mjs";
import { s as sleep } from "../../utils/sleep.mjs";
import { u as useScroll } from "./hooks/useScroll.mjs";
import { V as VaProgressCircle } from "../va-progress-circle/index.mjs";
import { u as useComponentPresetProp } from "../../composables/useComponentPreset.mjs";
import { u as useNumericProp } from "../../composables/useNumericProp.mjs";
import { u as useColors } from "../../composables/useColors.mjs";
const _hoisted_1 = { class: "va-infinite-scroll__spinner__default" };
const _sfc_main = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaInfiniteScroll"
  },
  __name: "VaInfiniteScroll",
  props: {
    ...useComponentPresetProp,
    load: { type: Function, required: true },
    offset: { type: [Number, String], default: 500 },
    reverse: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    scrollTarget: { type: [String, Object], default: null },
    debounce: { type: [Number, String], default: 100 },
    tag: { type: String, default: "div" }
  },
  emits: ["onload", "onerror"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const element = shallowRef();
    const spinnerSlotContainer = shallowRef();
    const fetching = ref(false);
    const error = ref(false);
    const forcedScrolling = ref(false);
    const debouncedLoad = ref();
    const notScrolledContentBeforeLoad = ref(0);
    const prevScrollTop = ref(0);
    const scrollTargetElement = computed(() => {
      var _a;
      let target;
      if (typeof props.scrollTarget === "string") {
        target = document.querySelector(props.scrollTarget);
      } else {
        target = props.scrollTarget || ((_a = element.value) == null ? void 0 : _a.parentElement);
      }
      return target || document.body;
    });
    const {
      addScrollListener,
      removeScrollListener
    } = useScroll(props, scrollTargetElement, debouncedLoad);
    const offsetComputed = useNumericProp("offset");
    const debounceComputed = useNumericProp("debounce");
    const { getColor } = useColors();
    const spinnerColor = computed(() => {
      return error.value ? getColor("danger") : getColor("primary");
    });
    const spinnerHeight = computed(() => {
      var _a;
      return ((_a = spinnerSlotContainer.value) == null ? void 0 : _a.offsetHeight) || 0;
    });
    const computedOffset = computed(() => {
      return offsetComputed.value + spinnerHeight.value;
    });
    const stop = () => {
      if (props.disabled) {
        return;
      }
      fetching.value = false;
      removeScrollListener();
    };
    const resume = () => {
      if (props.disabled) {
        return;
      }
      addScrollListener();
    };
    const onLoad = () => {
      const { scrollTop, scrollHeight, clientHeight } = scrollTargetElement.value;
      notScrolledContentBeforeLoad.value = scrollHeight - scrollTop;
      const scrollDelta = scrollTop - prevScrollTop.value;
      prevScrollTop.value = scrollTop;
      if (props.disabled || error.value || fetching.value) {
        return;
      }
      if (forcedScrolling.value) {
        forcedScrolling.value = false;
        return;
      }
      const isReverseScrollDirection = props.reverse && scrollDelta > 0 || !props.reverse && scrollDelta < 0;
      if (isReverseScrollDirection) {
        return;
      }
      const offset = props.reverse ? scrollTop : scrollHeight - scrollTop - clientHeight;
      if (offset > computedOffset.value) {
        return;
      }
      fetching.value = true;
      props.load().then(finishLoading).catch(onError);
    };
    const forceSetScrollTopToTarget = (value) => {
      forcedScrolling.value = true;
      scrollTargetElement.value.scrollTop = value;
    };
    const updateTargetElementScrollTop = () => {
      const { scrollTop, scrollHeight, clientHeight } = scrollTargetElement.value;
      if (props.reverse) {
        const isScrolledUp = scrollHeight - scrollTop < notScrolledContentBeforeLoad.value;
        const isSpinnerHidden = scrollTop >= spinnerHeight.value;
        if (isScrolledUp && isSpinnerHidden) {
          return;
        }
        scrollHeight - notScrolledContentBeforeLoad.value > spinnerHeight.value ? forceSetScrollTopToTarget(scrollHeight - notScrolledContentBeforeLoad.value) : forceSetScrollTopToTarget(spinnerHeight.value);
      }
      if (!props.reverse) {
        const isSpinnerHidden = scrollHeight - scrollTop - clientHeight >= spinnerHeight.value;
        !isSpinnerHidden && forceSetScrollTopToTarget(scrollHeight - clientHeight - spinnerHeight.value);
      }
    };
    const finishLoading = () => {
      updateTargetElementScrollTop();
      fetching.value = false;
      emit("onload");
    };
    const stopErrorDisplay = () => {
      updateTargetElementScrollTop();
      forcedScrolling.value = false;
      error.value = false;
      fetching.value = false;
      emit("onerror");
    };
    const onError = () => {
      stop();
      error.value = true;
      sleep(1200).then(stopErrorDisplay).then(resume);
    };
    watch(() => debounceComputed.value, (value) => {
      debouncedLoad.value = debounce(onLoad, value);
    }, { immediate: true });
    watch(() => props.disabled, (value) => {
      value ? stop() : resume();
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(resolveDynamicComponent(_ctx.$props.tag), {
        ref_key: "element",
        ref: element,
        role: "feed",
        class: normalizeClass(["va-infinite-scroll", { "va-infinite-scroll--reversed": _ctx.$props.reverse }]),
        "aria-busy": fetching.value
      }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default"),
          createElementVNode("div", {
            ref_key: "spinnerSlotContainer",
            ref: spinnerSlotContainer,
            class: normalizeClass(["va-infinite-scroll__spinner", { "va-infinite-scroll__spinner--invisible": !fetching.value }])
          }, [
            !_ctx.$props.disabled ? renderSlot(_ctx.$slots, "loading", { key: 0 }, () => [
              createElementVNode("div", _hoisted_1, [
                createVNode(unref(VaProgressCircle), {
                  size: "small",
                  thickness: 0.15,
                  color: spinnerColor.value,
                  indeterminate: ""
                }, null, 8, ["color"])
              ])
            ]) : createCommentVNode("", true)
          ], 2)
        ]),
        _: 3
      }, 8, ["class", "aria-busy"]);
    };
  }
});
export {
  _sfc_main as _
};
//# sourceMappingURL=VaInfiniteScroll.vue_vue_type_script_setup_true_lang.mjs.map
