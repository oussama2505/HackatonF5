import { defineComponent, shallowRef, useSlots, computed, toRefs, watch, useAttrs, openBlock, createBlock, unref, mergeProps, createSlots, withCtx, withModifiers, withKeys, createCommentVNode, renderSlot, normalizeProps, guardReactiveProps, createElementBlock, renderList } from "vue";
import { o as omit, p as pick } from "../../../vendor.mjs";
import { u as useCleaveProps, a as useCleave } from "./hooks/useCleave.mjs";
import { V as VaInputWrapper } from "../va-input-wrapper/index.mjs";
import { V as VaIcon } from "../va-icon/index.mjs";
import { c as combineFunctions } from "../../utils/combine-functions.mjs";
import { u as useFocusableProps, a as useFocusable } from "../../composables/useFocusable.mjs";
import { u as useClearableProps, a as useClearableEmits, b as useClearable } from "../../composables/useClearable.mjs";
import { b as useValidationProps, u as useValidationEmits, a as useValidation } from "../../composables/useValidation.mjs";
import { u as useDeprecatedCondition } from "../../composables/useDeprecatedCondition.mjs";
import { u as useEmitProxy } from "../../composables/useEmitProxy.mjs";
import { e as extractComponentProps } from "../../utils/component-options/extract-component-options.mjs";
import { u as useFormFieldProps } from "../../composables/useFormField.mjs";
import { u as useComponentPresetProp } from "../../composables/useComponentPreset.mjs";
import { u as useStatefulProps, a as useStatefulEmits, b as useStateful } from "../../composables/useStateful.mjs";
import { a as useTranslationProp, u as useTranslation } from "../../composables/useTranslation.mjs";
import { u as useEvent } from "../../composables/useEvent.mjs";
import { f as filterComponentProps } from "../../utils/component-options/filter-props.mjs";
const _hoisted_1 = ["value"];
const VaInputWrapperProps = extractComponentProps(VaInputWrapper);
const { createEmits: createInputEmits, createListeners: createInputListeners } = useEmitProxy(
  ["change", "keyup", "keypress", "keydown", "focus", "blur", "input"]
);
const { createEmits: createFieldEmits, createListeners: createFieldListeners } = useEmitProxy([
  "click",
  "click-prepend",
  "click-append",
  "click-prepend-inner",
  "click-append-inner"
]);
const _sfc_main = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaInput",
    inheritAttrs: false
  },
  __name: "VaInput",
  props: {
    ...VaInputWrapperProps,
    ...useFormFieldProps,
    ...useFocusableProps,
    ...useValidationProps,
    ...useClearableProps,
    ...useCleaveProps,
    ...useComponentPresetProp,
    ...useStatefulProps,
    // input
    placeholder: { type: String, default: "" },
    tabindex: { type: [String, Number], default: 0 },
    modelValue: { type: [Number, String, null], default: "" },
    type: { type: String, default: "text" },
    inputClass: { type: String, default: "" },
    pattern: { type: String },
    inputmode: { type: String, default: "text" },
    counter: { type: Boolean, default: false },
    // style
    ariaResetLabel: useTranslationProp("$t:reset"),
    /** Set value to input when model value is updated */
    strictBindInputValue: { type: Boolean, default: false }
  },
  emits: [
    "update:modelValue",
    ...useValidationEmits,
    ...useClearableEmits,
    ...createInputEmits(),
    ...createFieldEmits(),
    ...useStatefulEmits
  ],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit = __emit;
    useDeprecatedCondition([
      () => props.type !== "textarea" || 'Use VaTextarea component instead of VaInput with type="textarea"'
    ]);
    const input = shallowRef();
    const { valueComputed } = useStateful(props, emit, "modelValue");
    const reset = () => withoutValidation(() => {
      valueComputed.value = props.clearValue;
      emit("clear");
      resetValidation();
    });
    const { focus, blur } = useFocusable(input, props);
    const slots = useSlots();
    const filterSlots = computed(() => {
      const iconSlot = ["icon"];
      return Object.keys(slots).filter((slot) => !iconSlot.includes(slot));
    });
    const { tp } = useTranslation();
    const {
      isValid,
      isTouched,
      isDirty,
      computedError,
      computedErrorMessages,
      listeners: { onBlur },
      validationAriaAttributes,
      isLoading,
      withoutValidation,
      resetValidation
    } = useValidation(props, emit, { reset, focus, value: valueComputed });
    const { modelValue } = toRefs(props);
    const {
      canBeCleared,
      clearIconProps
    } = useClearable(props, modelValue, input, computedError);
    const { computedValue, onInput } = useCleave(input, props, valueComputed);
    const inputListeners = createInputListeners(emit);
    const inputEvents = {
      ...inputListeners,
      onBlur: combineFunctions(onBlur, inputListeners.onBlur),
      onInput: combineFunctions(onInput, inputListeners.onInput)
    };
    const setInputValue = (newValue) => {
      if (!props.strictBindInputValue) {
        return;
      }
      const target = input.value;
      if (!target) {
        return;
      }
      const selectionStart = target.selectionStart || 0;
      const selectionEnd = target.selectionEnd || 0;
      if (target.value !== newValue) {
        target.value = String(newValue);
      }
      target.setSelectionRange(selectionStart, selectionEnd);
    };
    watch(computedValue, (newValue) => {
      setInputValue(String(newValue));
    }, { immediate: true });
    useEvent("input", () => {
      setInputValue(String(valueComputed.value));
    }, input);
    const tabIndexComputed = computed(() => props.disabled ? -1 : props.tabindex);
    const attrs = useAttrs();
    const computedChildAttributes = computed(() => ({
      "aria-label": props.inputAriaLabel || props.label,
      "aria-labelledby": props.inputAriaLabelledby,
      "aria-required": props.requiredMark,
      tabindex: tabIndexComputed.value,
      class: props.inputClass,
      "aria-disabled": props.disabled,
      "aria-readonly": props.readonly,
      ...validationAriaAttributes.value,
      ...omit(attrs, ["class", "style"])
    }));
    const computedInputAttributes = computed(() => ({
      ...computedChildAttributes.value,
      ...pick(props, ["type", "disabled", "readonly", "placeholder", "pattern", "inputmode", "minlength", "maxlength", "name"])
    }));
    const valueLengthComputed = computed(
      () => props.counter && typeof computedValue.value === "string" ? computedValue.value.length : void 0
    );
    const onFieldClick = (e) => {
      if (!e.target || !("tagName" in e.target)) {
        return;
      }
      if (e.target.tagName === "INPUT" || e.target.tagName === "TEXTAREA") {
        return;
      }
      focus();
    };
    const wrapperProps = filterComponentProps(VaInputWrapperProps);
    const fieldListeners = createFieldListeners(emit);
    __expose({
      isValid,
      isDirty,
      isTouched,
      isLoading,
      computedError,
      computedErrorMessages,
      reset,
      focus,
      blur,
      value: valueComputed,
      withoutValidation,
      resetValidation
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(VaInputWrapper), mergeProps({
        ...unref(fieldListeners),
        ...unref(wrapperProps)
      }, {
        class: ["va-input", _ctx.$attrs.class],
        style: _ctx.$attrs.style,
        loading: _ctx.$props.loading || unref(isLoading),
        error: unref(computedError),
        "error-messages": unref(computedErrorMessages),
        "error-count": _ctx.errorCount,
        "counter-value": valueLengthComputed.value,
        onClick: onFieldClick
      }), createSlots({
        icon: withCtx((slotScope) => [
          unref(canBeCleared) ? (openBlock(), createBlock(unref(VaIcon), mergeProps({
            key: 0,
            role: "button",
            "aria-label": unref(tp)(_ctx.$props.ariaResetLabel)
          }, unref(clearIconProps), {
            onClick: withModifiers(reset, ["stop"]),
            onKeydown: [
              withKeys(withModifiers(reset, ["stop"]), ["enter"]),
              withKeys(withModifiers(reset, ["stop"]), ["space"])
            ]
          }), null, 16, ["aria-label", "onKeydown"])) : createCommentVNode("", true),
          renderSlot(_ctx.$slots, "icon", normalizeProps(guardReactiveProps(slotScope)))
        ]),
        default: withCtx(() => [
          !_ctx.$slots.content ? (openBlock(), createElementBlock("input", mergeProps({
            key: 0,
            ref_key: "input",
            ref: input,
            class: "va-input__content__input"
          }, { ...computedInputAttributes.value, ...inputEvents }, { value: unref(computedValue) }), null, 16, _hoisted_1)) : createCommentVNode("", true)
        ]),
        _: 2
      }, [
        renderList(filterSlots.value, (name) => {
          return {
            name,
            fn: withCtx((slotScope) => [
              renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps(slotScope)))
            ])
          };
        })
      ]), 1040, ["class", "style", "loading", "error", "error-messages", "error-count", "counter-value"]);
    };
  }
});
export {
  _sfc_main as _
};
//# sourceMappingURL=VaInput.vue_vue_type_script_setup_true_lang.mjs.map
