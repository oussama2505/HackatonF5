import { defineComponent, shallowRef, computed, openBlock, createBlock, unref, normalizeStyle, withCtx, createElementVNode, mergeProps, createElementBlock, Fragment, renderList, normalizeClass, renderSlot, normalizeProps, guardReactiveProps, createTextVNode, toDisplayString, createCommentVNode } from "vue";
import { u as useComponentUuid } from "../../composables/useComponentUuid.mjs";
import { _ as _sfc_main$1 } from "../va-message-list/VaMessageListWrapper.vue_vue_type_script_setup_true_lang.mjs";
import { u as useSelectableProps, a as useSelectableEmits, b as useSelectable } from "../../composables/useSelectable.mjs";
import { u as useComponentPresetProp } from "../../composables/useComponentPreset.mjs";
import { u as useSelectableListProps, a as useSelectableList } from "../../composables/useSelectableList.mjs";
import { u as useColors } from "../../composables/useColors.mjs";
const _hoisted_1 = ["role"];
const _hoisted_2 = ["value", "checked", "aria-checked", "onChange"];
const _hoisted_3 = /* @__PURE__ */ createElementVNode("span", {
  "aria-hidden": "true",
  class: "va-radio__icon"
}, [
  /* @__PURE__ */ createElementVNode("span", { class: "va-radio__icon__background" }),
  /* @__PURE__ */ createElementVNode("span", { class: "va-radio__icon__dot" })
], -1);
const _sfc_main = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaRadio"
  },
  __name: "VaRadio",
  props: {
    ...useSelectableProps,
    ...useComponentPresetProp,
    ...useSelectableListProps,
    modelValue: {
      type: [Boolean, Array, String, Object, Number],
      default: null
    },
    options: {
      type: Array,
      default: () => []
    },
    name: { type: String, default: "" },
    label: { type: String, default: void 0 },
    leftLabel: { type: Boolean, default: false },
    color: { type: String, default: "primary" },
    option: {
      type: [Object, String, Number],
      default: void 0
    },
    vertical: { type: Boolean, default: false }
  },
  emits: useSelectableEmits,
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { getColor } = useColors();
    const elements = {
      container: shallowRef(),
      input: shallowRef(),
      label: shallowRef()
    };
    const {
      computedError,
      computedErrorMessages,
      validationAriaAttributes,
      onBlur,
      onFocus
    } = useSelectable(props, emit, elements);
    const { getText: originalGetText, getDisabled: originalGetDisabled, getValue } = useSelectableList(props);
    const getText = (option) => {
      if (props.options.length > 0) {
        return originalGetText(option);
      }
      return props.label ?? originalGetText(option);
    };
    const getDisabled = (option) => originalGetDisabled(option) || props.disabled;
    const isNoOption = computed(() => props.options.length === 0 && !props.option);
    const isChecked = (option) => {
      if (isNoOption.value) {
        return props.modelValue;
      }
      return props.modelValue === getValue(option);
    };
    const computedOptions = computed(() => {
      if (isNoOption.value) {
        return [{}];
      }
      if (props.option) {
        return [props.option];
      } else {
        return props.options;
      }
    });
    const radioClass = (option) => ({
      "va-radio--left-label": props.leftLabel,
      "va-radio--selected": isChecked(option),
      "va-radio--readonly": props.readonly,
      "va-radio--disabled": props.disabled,
      "va-radio--indeterminate": props.indeterminate,
      "va-radio--error": computedError.value,
      "va-radio--single-option": isNoOption.value
    });
    const selectOption = (option, event) => {
      var _a;
      if (isNoOption.value) {
        emit("update:modelValue", ((_a = event == null ? void 0 : event.target) == null ? void 0 : _a.checked) || false);
        return;
      }
      emit("update:modelValue", option);
    };
    const labelStyle = computed(() => {
      return {
        color: computedError.value ? getColor("danger") : ""
      };
    });
    computed(() => {
      const style = {
        background: getColor(props.color),
        borderColor: getColor(props.color)
      };
      if (computedError.value) {
        style.borderColor = getColor("danger");
      }
      return style;
    });
    const iconBackgroundComputedStyles = computed(() => ({
      backgroundColor: getColor(props.color)
    }));
    const iconDotComputedStyles = computed(() => {
      return {
        borderColor: computedError.value ? getColor("danger") : getColor(props.color),
        backgroundColor: getColor(props.color)
      };
    });
    const iconComputedStyles = computed(() => {
      return { borderColor: computedError.value ? getColor("danger") : getColor(props.color) };
    });
    const componentId = useComponentUuid();
    const computedName = computed(() => props.name || componentId);
    const inputAttributesComputed = (option) => {
      const disabled = getDisabled(option);
      return {
        name: computedName.value,
        disabled,
        readonly: props.readonly,
        tabindex: disabled ? -1 : 0
      };
    };
    const flexDirection = computed(() => props.vertical ? "column" : "row");
    const roleComputed = computed(() => {
      var _a;
      return ((_a = props.options) == null ? void 0 : _a.length) > 0 ? "radiogroup" : "";
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(_sfc_main$1), {
        disabled: _ctx.disabled,
        success: _ctx.success,
        messages: _ctx.messages,
        error: unref(computedError),
        "error-messages": unref(computedErrorMessages),
        "error-count": _ctx.errorCount,
        onBlur: unref(onBlur),
        style: normalizeStyle(`--va-flex-direction: ${String(flexDirection.value)};--va-label-style-color: ${String(labelStyle.value.color)};--va-icon-computed-styles-border-color: ${String(iconComputedStyles.value.borderColor)};--va-icon-dot-computed-styles-border-color: ${String(iconDotComputedStyles.value.borderColor)};--va-icon-dot-computed-styles-background-color: ${String(iconDotComputedStyles.value.backgroundColor)};--va-icon-background-computed-styles-background-color: ${String(iconBackgroundComputedStyles.value.backgroundColor)}`)
      }, {
        default: withCtx(({ ariaAttributes }) => [
          createElementVNode("div", mergeProps({
            ref: "container",
            class: "va-radio",
            role: roleComputed.value
          }, ariaAttributes), [
            (openBlock(true), createElementBlock(Fragment, null, renderList(computedOptions.value, (option, index) => {
              return openBlock(), createElementBlock("label", {
                key: index,
                class: normalizeClass([radioClass(option), "va-radio__square"])
              }, [
                createElementVNode("input", mergeProps({
                  ref_for: true,
                  ref: "input",
                  class: "va-radio__input",
                  type: "radio",
                  role: "radio",
                  value: isChecked(option),
                  checked: isChecked(option),
                  "aria-checked": isChecked(option)
                }, { ...inputAttributesComputed(option), ...ariaAttributes }, {
                  onChange: ($event) => selectOption(unref(getValue)(option), $event),
                  onFocus: _cache[0] || (_cache[0] = //@ts-ignore
                  (...args) => unref(onFocus) && unref(onFocus)(...args)),
                  onBlur: _cache[1] || (_cache[1] = //@ts-ignore
                  (...args) => unref(onBlur) && unref(onBlur)(...args))
                }), null, 16, _hoisted_2),
                renderSlot(_ctx.$slots, "icon", normalizeProps(guardReactiveProps({
                  value: isChecked(option),
                  text: getText(option),
                  disabled: getDisabled(option),
                  index
                })), () => [
                  _hoisted_3
                ]),
                getText(option) || _ctx.$slots.default ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  ref_for: true,
                  ref: "label",
                  class: "va-radio__text"
                }, [
                  renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps({
                    value: isChecked(option),
                    text: getText(option),
                    disabled: getDisabled(option),
                    index
                  })), () => [
                    createTextVNode(toDisplayString(getText(option)), 1)
                  ])
                ], 512)) : createCommentVNode("", true)
              ], 2);
            }), 128))
          ], 16, _hoisted_1)
        ]),
        _: 3
      }, 8, ["disabled", "success", "messages", "error", "error-messages", "error-count", "onBlur", "style"]);
    };
  }
});
export {
  _sfc_main as _
};
//# sourceMappingURL=VaRadio.vue_vue_type_script_setup_true_lang.mjs.map
