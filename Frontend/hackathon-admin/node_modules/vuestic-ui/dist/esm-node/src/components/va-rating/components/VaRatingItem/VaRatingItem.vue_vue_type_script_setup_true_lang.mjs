import { defineComponent, shallowRef, ref, computed, watch, openBlock, createElementBlock, withKeys, withModifiers, renderSlot, normalizeProps, guardReactiveProps, createVNode, unref } from "vue";
import { R as RatingValue } from "../../types.mjs";
import { V as VaIcon } from "../../../va-icon/index.mjs";
import { u as useSyncProp } from "../../../../composables/useSyncProp.mjs";
import { u as useColors } from "../../../../composables/useColors.mjs";
const _hoisted_1 = ["tabindex", "onKeydown"];
const _sfc_main = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaRatingItem"
  },
  __name: "VaRatingItem",
  props: {
    modelValue: { type: Number, default: 0 },
    icon: { type: String, default: "star" },
    halfIcon: { type: String, default: "star_half" },
    emptyIcon: { type: String, default: "star_outline" },
    halves: { type: Boolean, default: false },
    hover: { type: Boolean, default: false },
    tabindex: { type: [String, Number], default: 0 },
    disabled: { type: Boolean, default: false },
    readonly: { type: Boolean, default: false },
    size: { type: [String, Number], default: "medium" },
    unselectedColor: { type: String },
    color: { type: String, default: "primary" }
  },
  emits: ["update:modelValue", "click", "hover"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const rootEl = shallowRef();
    const [modelValue] = useSyncProp("modelValue", props, emit, RatingValue.EMPTY);
    const hoveredValue = ref(null);
    const visibleValue = computed(() => {
      if (props.hover && !props.disabled && !props.readonly) {
        return hoveredValue.value || modelValue.value;
      }
      return modelValue.value;
    });
    const { getColor } = useColors();
    const computedColor = computed(() => getColor(
      props.unselectedColor && visibleValue.value === RatingValue.EMPTY ? props.unselectedColor : props.color
    ));
    const onMouseMove = (ev) => {
      if (!rootEl.value) {
        return;
      }
      const { offsetX } = ev;
      const iconWidth = rootEl.value.clientWidth;
      if (props.halves) {
        hoveredValue.value = offsetX / iconWidth <= RatingValue.HALF ? RatingValue.HALF : RatingValue.FULL;
      } else {
        hoveredValue.value = RatingValue.FULL;
      }
    };
    const onMouseLeave = () => {
      hoveredValue.value = null;
    };
    const onClick = () => {
      modelValue.value = hoveredValue.value || RatingValue.FULL;
      emit("click", hoveredValue.value || RatingValue.FULL);
    };
    watch(hoveredValue, () => emit("hover", hoveredValue.value || RatingValue.EMPTY));
    const computedIconName = computed(() => {
      if (props.halves && visibleValue.value === RatingValue.HALF) {
        return props.halfIcon;
      }
      if (visibleValue.value === RatingValue.EMPTY) {
        return props.emptyIcon;
      }
      return props.icon;
    });
    const tabIndexComputed = computed(() => props.disabled ? -1 : props.tabindex);
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        ref_key: "rootEl",
        ref: rootEl,
        role: "button",
        class: "va-rating-item",
        tabindex: tabIndexComputed.value,
        onKeydown: [
          withKeys(onClick, ["enter"]),
          withKeys(withModifiers(onClick, ["prevent"]), ["space"])
        ],
        onMousemove: onMouseMove,
        onMouseleave: onMouseLeave,
        onClick
      }, [
        renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps({ value: visibleValue.value, onClick })), () => [
          createVNode(unref(VaIcon), {
            class: "va-rating-item__wrapper",
            tabindex: "-1",
            tag: "button",
            name: computedIconName.value,
            size: _ctx.$props.size,
            color: computedColor.value
          }, null, 8, ["name", "size", "color"])
        ])
      ], 40, _hoisted_1);
    };
  }
});
export {
  _sfc_main as _
};
//# sourceMappingURL=VaRatingItem.vue_vue_type_script_setup_true_lang.mjs.map
