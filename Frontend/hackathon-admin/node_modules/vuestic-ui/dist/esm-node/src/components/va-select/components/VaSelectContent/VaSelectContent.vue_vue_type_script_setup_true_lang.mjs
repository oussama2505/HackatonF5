import { defineComponent, ref, computed, toRefs, onMounted, watch, openBlock, createElementBlock, createElementVNode, mergeProps, renderSlot, normalizeProps, Fragment, renderList, guardReactiveProps, createBlock, unref, createCommentVNode, createTextVNode, toDisplayString, withDirectives, withKeys, withModifiers, vModelDynamic } from "vue";
import { V as VaIcon } from "../../../va-icon/index.mjs";
import { V as VaBadge } from "../../../va-badge/index.mjs";
import { i as isObject } from "../../../../utils/is-object.mjs";
import { u as useFormFieldProps } from "../../../../composables/useFormField.mjs";
import { u as useNumericProp } from "../../../../composables/useNumericProp.mjs";
const _hoisted_1 = {
  key: 0,
  class: "va-select-content__placeholder"
};
const _hoisted_2 = ["placeholder"];
const _hoisted_3 = {
  key: 0,
  class: "va-select-content__option"
};
const _hoisted_4 = {
  key: 1,
  class: "va-select-content__separator"
};
const _hoisted_5 = ["placeholder", "disabled", "readonly"];
const _sfc_main = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaSelectContent"
  },
  __name: "VaSelectContent",
  props: {
    ...useFormFieldProps,
    ariaAttributes: { type: Object },
    value: { type: Array, required: true },
    valueString: { type: String },
    separator: { type: String, default: ", " },
    placeholder: { type: String, default: "" },
    tabindex: { type: [String, Number], default: 0 },
    hiddenSelectedOptionsAmount: { type: [Number, String], default: 0 },
    isAllOptionsShown: { type: Boolean, default: false },
    autocomplete: { type: Boolean, default: false },
    focused: { type: Boolean, default: false },
    multiple: { type: Boolean, default: false },
    getText: { type: Function, required: true },
    autocompleteInputValue: { type: String, default: "" }
  },
  emits: ["toggle-hidden", "autocomplete-input", "focus-prev", "focus-next", "select-option", "delete-last-selected"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const autocompleteInput = ref();
    const isPlaceholder = computed(() => props.placeholder && !props.valueString);
    const toggleHiddenOptionsState = () => emit("toggle-hidden");
    const { value, focused } = toRefs(props);
    const autocompleteInputValueComputed = computed({
      get: () => props.autocompleteInputValue,
      set: (v) => emit("autocomplete-input", v)
    });
    const hiddenSelectedOptionsAmountComputed = useNumericProp("hiddenSelectedOptionsAmount");
    onMounted(() => {
      if (props.multiple) {
        return;
      }
      if (!props.autocomplete) {
        return;
      }
      autocompleteInputValueComputed.value = props.valueString;
    });
    watch(focused, (newValue) => {
      var _a, _b;
      if (!props.autocomplete || !newValue) {
        return;
      }
      if (autocompleteInputValueComputed.value) {
        (_a = autocompleteInput.value) == null ? void 0 : _a.setSelectionRange(0, autocompleteInputValueComputed.value.length);
      } else {
        (_b = autocompleteInput.value) == null ? void 0 : _b.focus();
      }
    });
    const handleBackspace = (e) => {
      if (props.multiple && value.value.length && e.key === "Backspace" && !autocompleteInputValueComputed.value) {
        emit("delete-last-selected");
      }
    };
    const handleClick = (e) => {
      var _a;
      if (props.autocomplete) {
        (_a = autocompleteInput.value) == null ? void 0 : _a.focus();
        e.stopPropagation();
      }
    };
    const getIcon = (option) => isObject(option) ? option.icon : void 0;
    const slotValue = computed(() => {
      if (props.multiple) {
        return value.value;
      }
      return value.value[0];
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "va-select-content",
        onClick: handleClick
      }, [
        isPlaceholder.value && !_ctx.$props.autocomplete ? (openBlock(), createElementBlock("span", _hoisted_1, [
          createElementVNode("input", mergeProps(__props.ariaAttributes, {
            placeholder: _ctx.$props.placeholder,
            readonly: ""
          }), null, 16, _hoisted_2)
        ])) : !(props.autocomplete && !props.multiple) ? renderSlot(_ctx.$slots, "content", normalizeProps(mergeProps({ key: 1 }, {
          value: slotValue.value,
          valueString: _ctx.$props.valueString,
          valueArray: _ctx.$props.value,
          tabindex: _ctx.$props.tabindex,
          ariaAttributes: __props.ariaAttributes
        })), () => [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.$props.value, (option, index) => {
            return openBlock(), createElementBlock(Fragment, { key: index }, [
              option !== "" ? (openBlock(), createElementBlock("span", _hoisted_3, [
                renderSlot(_ctx.$slots, "option-content", normalizeProps(guardReactiveProps({ option, index, selectOption: () => void 0 })), () => [
                  getIcon(option) ? (openBlock(), createBlock(unref(VaIcon), {
                    key: 0,
                    size: "small",
                    class: "va-select-option__icon",
                    name: getIcon(option)
                  }, null, 8, ["name"])) : createCommentVNode("", true),
                  createTextVNode(" " + toDisplayString(__props.getText(option)), 1)
                ])
              ])) : createCommentVNode("", true),
              index < _ctx.$props.value.length - 1 ? (openBlock(), createElementBlock("span", _hoisted_4, toDisplayString(_ctx.$props.separator), 1)) : createCommentVNode("", true)
            ], 64);
          }), 128))
        ]) : createCommentVNode("", true),
        _ctx.$props.autocomplete ? withDirectives((openBlock(), createElementBlock("input", mergeProps({ key: 2 }, __props.ariaAttributes, {
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => autocompleteInputValueComputed.value = $event),
          class: "va-select-content__autocomplete",
          ref_key: "autocompleteInput",
          ref: autocompleteInput,
          autocomplete: "off",
          "aria-autocomplete": "list",
          placeholder: _ctx.$props.placeholder,
          disabled: _ctx.$props.disabled,
          readonly: _ctx.$props.readonly,
          onKeydown: [
            _cache[1] || (_cache[1] = withKeys(withModifiers(($event) => _ctx.$emit("focus-prev"), ["stop", "prevent"]), ["up"])),
            _cache[2] || (_cache[2] = withKeys(withModifiers(($event) => _ctx.$emit("focus-next"), ["stop", "prevent"]), ["down"])),
            _cache[3] || (_cache[3] = withKeys(withModifiers(($event) => _ctx.$emit("select-option"), ["stop", "prevent"]), ["enter"])),
            handleBackspace
          ]
        }), null, 16, _hoisted_5)), [
          [vModelDynamic, autocompleteInputValueComputed.value]
        ]) : createCommentVNode("", true),
        renderSlot(_ctx.$slots, "hiddenOptionsBadge", normalizeProps(guardReactiveProps({
          amount: __props.hiddenSelectedOptionsAmount,
          isShown: _ctx.$props.isAllOptionsShown,
          toggle: toggleHiddenOptionsState
        })), () => [
          unref(hiddenSelectedOptionsAmountComputed) && !_ctx.$props.isAllOptionsShown ? (openBlock(), createBlock(unref(VaBadge), {
            key: 0,
            class: "va-select-content__state-icon",
            color: "info",
            text: `+${unref(hiddenSelectedOptionsAmountComputed)}`,
            tabindex: _ctx.$props.tabindex,
            onClick: withModifiers(toggleHiddenOptionsState, ["stop"])
          }, null, 8, ["text", "tabindex"])) : createCommentVNode("", true)
        ]),
        renderSlot(_ctx.$slots, "hideOptionsButton", normalizeProps(guardReactiveProps({
          isShown: _ctx.$props.isAllOptionsShown,
          toggle: toggleHiddenOptionsState
        })), () => [
          _ctx.$props.isAllOptionsShown ? (openBlock(), createBlock(unref(VaIcon), {
            key: 0,
            role: "button",
            class: "va-select-content__state-icon",
            size: "small",
            name: "reply",
            tabindex: _ctx.$props.tabindex,
            onClick: withModifiers(toggleHiddenOptionsState, ["stop"])
          }, null, 8, ["tabindex"])) : createCommentVNode("", true)
        ])
      ]);
    };
  }
});
export {
  _sfc_main as _
};
//# sourceMappingURL=VaSelectContent.vue_vue_type_script_setup_true_lang.mjs.map
