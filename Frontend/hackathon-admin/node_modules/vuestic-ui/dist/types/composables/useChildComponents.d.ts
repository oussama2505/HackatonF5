import { ComputedRef, PropType } from 'vue';
import { DefineComponentOptions, ExtractComponentPropTypes } from '../utils/component-options';
declare const CHILD_COMPONENT_PROP_PREFIX = "child:";
type ChildComponents = Record<string, DefineComponentOptions>;
type NonSymbol<T> = T extends symbol ? never : T;
/** @example Converts `{ closeButton: VaButton }` to `{ child:closeButton: ExtractComponentPropTypes<VaButton> }` */
type ChildComponentsPropsDefinition<T extends ChildComponents> = {
    [K in keyof T as `${typeof CHILD_COMPONENT_PROP_PREFIX}${NonSymbol<K>}`]: {
        type: PropType<ExtractComponentPropTypes<T[K]>>;
        required: false;
        default: undefined;
    };
};
/**
 * Creates type definition for props. No runtime code is generated.
 * Creates new props with `child:` prefix, add names of child components and their props.
 *
 * @example
 *
 * Following code will generate new prop `child:closeButton` with type equal to `VaButton` props object.
 *
 * ```ts
 * const defineChildProps = defineChildComponents<{
 *  closeButton: VaButton
 * }>()
 * ```
 */
export declare const defineChildProps: <T extends ChildComponents>(obj: T) => ChildComponentsPropsDefinition<T>;
/** @notice No chaining for now. We assume component names as uniq across component tree */
export declare const useChildComponents: (props: Record<`${typeof CHILD_COMPONENT_PROP_PREFIX}${string}`, any>) => void;
export declare const injectChildPropsFromParent: () => ComputedRef<Record<string, any>> | null;
export declare const injectChildPresetPropFromParent: () => ComputedRef<string> | null;
export {};
