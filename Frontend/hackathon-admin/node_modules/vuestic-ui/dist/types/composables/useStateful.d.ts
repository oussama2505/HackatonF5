import { type PropType, type WritableComputedRef } from 'vue';
export type StatefulProps = {
    stateful: boolean;
};
export type StatefulOptions<T> = {
    eventName?: string;
    /** Prefer to set default value for prop, not here. */
    defaultValue?: T;
};
/**
 * You could add these props to any component by destructuring them inside props option.
 * @example
 * props: { ...useStatefulProps, componentsOwnProp, etc. }
 * It's better to add props at the beginning, to make sure that Component own props will be used instead in case of collision
 */
export declare const useStatefulProps: {
    stateful: {
        type: PropType<boolean>;
        default: boolean;
    };
    modelValue: {
        type: any;
    };
};
export declare const createStatefulProps: (statefulDefault?: boolean) => {
    stateful: {
        type: PropType<boolean>;
        default: boolean;
    };
};
export declare const useStatefulEmits: readonly ["update:modelValue"];
export type StatefulValue<V> = WritableComputedRef<V> & {
    /** If stateful, means value has inner state, not related to user passed by v-model */
    stateful: boolean;
    /** Indicates if props passed by user. If `false`, means default props value is used. */
    userProvided: boolean;
};
/**
 * Returns `valueComputed` that is proxy for `modelValue` or given key of the props
 * if `stateful` prop is `false`
 * Record<any, any> & Record<'modelValue', T>
 */
export declare const useStateful: <T, Key extends string = "modelValue", D = T, P extends StatefulProps & (Record<Key, T> | { readonly [key in Key]?: T | undefined; }) = StatefulProps & (Record<Key, T> | { readonly [key_1 in Key]?: T | undefined; }), E extends (name: `update:${Key}`, ...args: any[]) => void = (name: `update:${Key}`, ...args: any[]) => void>(props: P, emit: E, key?: Key, options?: StatefulOptions<D>) => {
    valueComputed: StatefulValue<P[Key]>;
};
