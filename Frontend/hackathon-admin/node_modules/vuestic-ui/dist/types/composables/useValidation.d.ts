import { type PropType, type ExtractPropTypes, type WritableComputedRef, type Ref } from 'vue';
export type ValidationRule<V = any> = ((v: V) => any | string) | Promise<((v: V) => any | string)>;
type UseValidationOptions = {
    reset: () => void;
    focus: () => void;
    value: WritableComputedRef<any> | Ref<any>;
};
export declare const useValidationProps: {
    name: {
        type: StringConstructor;
        default: undefined;
    };
    rules: {
        type: PropType<ValidationRule<any>[]>;
        default: () => any;
    };
    dirty: {
        type: BooleanConstructor;
        default: boolean;
    };
    error: {
        type: BooleanConstructor;
        default: undefined;
    };
    errorMessages: {
        type: PropType<string | string[]>;
        default: undefined;
    };
    errorCount: {
        type: (StringConstructor | NumberConstructor)[];
        default: number;
    };
    success: {
        type: BooleanConstructor;
        default: boolean;
    };
    messages: {
        type: PropType<string | string[]>;
        default: () => never[];
    };
    immediateValidation: {
        type: BooleanConstructor;
        default: boolean;
    };
    modelValue: {};
};
export type ValidationProps<V, RulesArgument extends V = V> = {
    rules: {
        type: PropType<ValidationRule<RulesArgument>[]>;
        default: () => any;
        required: false;
    };
    modelValue: {
        type: PropType<V>;
        default: V;
    };
} & Omit<typeof useValidationProps, 'modelValue' | 'rules'>;
export declare const useValidationEmits: readonly ["update:error", "update:errorMessages", "update:dirty"];
export declare const useValidation: <V, P extends ExtractPropTypes<{
    name: {
        type: StringConstructor;
        default: undefined;
    };
    rules: {
        type: PropType<ValidationRule<any>[]>;
        default: () => any;
    };
    dirty: {
        type: BooleanConstructor;
        default: boolean;
    };
    error: {
        type: BooleanConstructor;
        default: undefined;
    };
    errorMessages: {
        type: PropType<string | string[]>;
        default: undefined;
    };
    errorCount: {
        type: (StringConstructor | NumberConstructor)[];
        default: number;
    };
    success: {
        type: BooleanConstructor;
        default: boolean;
    };
    messages: {
        type: PropType<string | string[]>;
        default: () => never[];
    };
    immediateValidation: {
        type: BooleanConstructor;
        default: boolean;
    };
    modelValue: {};
}>>(props: P, emit: (event: any, ...args: any[]) => void, options: UseValidationOptions) => {
    isDirty: Ref<boolean>;
    isValid: import("vue").ComputedRef<boolean>;
    isError: WritableComputedRef<boolean>;
    isTouched: Ref<boolean>;
    isLoading: WritableComputedRef<boolean>;
    computedError: import("vue").ComputedRef<boolean>;
    computedErrorMessages: import("vue").ComputedRef<string[]>;
    listeners: {
        onBlur: () => void;
    };
    validate: () => any;
    resetValidation: () => void;
    withoutValidation: (cb: () => any) => void;
    validationAriaAttributes: import("vue").ComputedRef<{
        'aria-invalid': boolean;
        'aria-errormessage': string;
    }>;
};
export {};
