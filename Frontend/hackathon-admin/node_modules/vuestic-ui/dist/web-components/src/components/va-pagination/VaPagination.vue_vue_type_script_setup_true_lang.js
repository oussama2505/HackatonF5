import { defineComponent, shallowRef, ref, computed, toRefs, watch, openBlock, createElementBlock, normalizeClass, unref, withKeys, withModifiers, renderSlot, normalizeProps, mergeProps, createBlock, createCommentVNode, Fragment, renderList, withCtx, createTextVNode, toDisplayString, withDirectives, vModelDynamic, nextTick } from "vue";
import { p as pick, b as clamp } from "../../../vendor.js";
import { i as isDev } from "../../utils/env.js";
import { s as setPaginationRange } from "./setPaginationRange.js";
import { V as VaButton } from "../va-button/index.js";
import { u as useStatefulProps, a as useStatefulEmits, b as useStateful } from "../../composables/useStateful.js";
import { u as useComponentPresetProp } from "../../composables/useComponentPreset.js";
import { a as useTranslationProp, u as useTranslation } from "../../composables/useTranslation.js";
import { u as useNumericProp } from "../../composables/useNumericProp.js";
import { u as useArrayRefs } from "../../composables/useArrayRefs.js";
import { u as useColors } from "../../composables/useColors.js";
import { u as useBem } from "../../composables/useBem.js";
const _hoisted_1 = ["aria-label", "onKeydown"];
const _hoisted_2 = ["aria-label"];
const _sfc_main = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaPagination"
  },
  __name: "VaPagination",
  props: {
    ...useStatefulProps,
    ...useComponentPresetProp,
    modelValue: { type: Number, default: 1 },
    visiblePages: { type: [Number, String], default: 0 },
    pages: { type: [Number, String], default: 0 },
    disabled: { type: Boolean, default: false },
    color: { type: String, default: "primary" },
    size: {
      type: String,
      default: "medium",
      validator: (v) => ["small", "medium", "large"].includes(v)
    },
    boundaryLinks: { type: Boolean, default: true },
    boundaryNumbers: { type: Boolean, default: false },
    directionLinks: { type: Boolean, default: true },
    input: { type: Boolean, default: false },
    hideOnSinglePage: { type: Boolean, default: false },
    total: { type: [Number, String], default: null },
    pageSize: { type: [Number, String], default: null },
    boundaryIconLeft: { type: String, default: "va-arrow-first" },
    boundaryIconRight: { type: String, default: "va-arrow-last" },
    directionIconLeft: { type: String, default: "va-arrow-left" },
    directionIconRight: { type: String, default: "va-arrow-right" },
    gapped: { type: Boolean, default: false },
    borderColor: { type: String, default: "" },
    rounded: { type: Boolean, default: false },
    /** @deprecated Use activeButtonProps="{ color: 'myColor' }" */
    activePageColor: { type: String, default: "" },
    activeButtonProps: { type: Object, default: () => ({}) },
    buttonProps: { type: Object, default: () => ({}) },
    buttonsPreset: { type: String, default: "primary" },
    ariaLabel: useTranslationProp("$t:pagination"),
    ariaGoToTheFirstPageLabel: useTranslationProp("$t:goToTheFirstPage"),
    ariaGoToPreviousPageLabel: useTranslationProp("$t:goToPreviousPage"),
    ariaGoToSpecificPageLabel: useTranslationProp("$t:goToSpecificPage"),
    ariaGoToSpecificPageInputLabel: useTranslationProp("$t:goToSpecificPageInput"),
    ariaGoToNextPageLabel: useTranslationProp("$t:goNextPage"),
    ariaGoToLastPageLabel: useTranslationProp("$t:goLastPage")
  },
  emits: [...useStatefulEmits],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const htmlInput = shallowRef();
    const inputValue = ref("");
    const usesTotal = computed(() => !!((totalComputed.value || totalComputed.value === 0) && pageSizeComputed.value));
    const { valueComputed } = useStateful(props, emit);
    const currentValue = computed({
      get: () => usesTotal.value ? Math.ceil(valueComputed.value / pageSizeComputed.value) || 1 : valueComputed.value,
      set: (value) => {
        valueComputed.value = value;
      }
    });
    const visiblePagesComputed = useNumericProp("visiblePages");
    const pagesComputed = useNumericProp("pages");
    const totalComputed = useNumericProp("total");
    const pageSizeComputed = useNumericProp("pageSize");
    const paginationRange = computed(() => {
      const { boundaryNumbers } = props;
      const value = currentValue.value || 1;
      const totalPages = usesTotal.value ? Math.ceil(totalComputed.value / pageSizeComputed.value) : pagesComputed.value;
      return setPaginationRange(value, visiblePagesComputed.value, totalPages, boundaryNumbers);
    });
    const lastPage = computed(() => usesTotal.value ? Math.ceil(totalComputed.value / pageSizeComputed.value) || 1 : +pagesComputed.value);
    const isLastPageNotVisible = computed(() => !!visiblePagesComputed.value && lastPage.value > visiblePagesComputed.value || props.input);
    const showBoundaryLinks = computed(() => {
      const { boundaryLinks, boundaryNumbers } = props;
      return isLastPageNotVisible.value && boundaryLinks && !boundaryNumbers;
    });
    const showDirectionLinks = computed(() => isLastPageNotVisible.value && props.directionLinks);
    const showPagination = computed(() => lastPage.value > 1 || !props.hideOnSinglePage && lastPage.value <= 1);
    const focusInput = () => {
      inputValue.value = String(currentValue.value);
      nextTick(() => {
        var _a;
        return (_a = htmlInput.value) == null ? void 0 : _a.setSelectionRange(0, htmlInput.value.value.length);
      });
    };
    const { setItemRefByIndex, itemRefs } = useArrayRefs();
    const onUserInput = (pageNum) => {
      var _a;
      if (pageNum === "..." || pageNum === currentValue.value) {
        return;
      }
      const limitedPageNum = clamp(pageNum, 1, lastPage.value);
      currentValue.value = usesTotal.value ? (limitedPageNum - 1) * pageSizeComputed.value + 1 : limitedPageNum;
      (_a = itemRefs.value[pageNum - 1]) == null ? void 0 : _a.focus();
    };
    const resetInput = () => {
      var _a;
      inputValue.value = "";
      (_a = htmlInput.value) == null ? void 0 : _a.blur();
    };
    const changeValue = () => {
      if (+inputValue.value === currentValue.value) {
        resetInput();
      }
      if (!inputValue.value.length) {
        return;
      }
      let pageNum = Number.parseInt(inputValue.value);
      switch (true) {
        case pageNum < 1:
          pageNum = 1;
          break;
        case pageNum > lastPage.value:
          pageNum = lastPage.value;
          break;
        case isNaN(pageNum):
          pageNum = currentValue.value;
          break;
      }
      onUserInput(pageNum);
      resetInput();
    };
    const { getColor, colorToRgba } = useColors();
    const inputBorderColorComputed = computed(() => {
      const { color, buttonsPreset } = toRefs(props);
      if (!color.value) {
        return "transparent";
      }
      switch (buttonsPreset.value) {
        case "default":
          return getColor(color.value);
        case void 0:
        case "primary":
          return colorToRgba(getColor(color.value), 0.1);
        default:
          return "transparent";
      }
    });
    const inputStyleComputed = computed(() => ({
      cursor: "default",
      color: getColor(props.color),
      opacity: props.disabled ? 0.4 : 1,
      borderColor: inputBorderColorComputed.value
    }));
    watch([usesTotal, () => pagesComputed.value], () => {
      if (isDev && usesTotal.value && pagesComputed.value) {
        throw new Error("Please, use either `total` and `page-size` props, or `pages`.");
      }
    });
    const inputAttributesComputed = computed(() => ({
      disabled: props.disabled,
      placeholder: `${currentValue.value}/${lastPage.value}`
    }));
    const buttonPropsComputed = computed(() => ({
      size: props.size,
      preset: props.buttonsPreset,
      color: props.color,
      borderColor: props.borderColor,
      round: props.rounded,
      ...props.buttonProps
    }));
    const currentPageButtonProps = computed(() => ({
      preset: props.buttonsPreset === "default" ? "primary" : "default",
      color: props.activePageColor || props.color,
      ...props.activeButtonProps
    }));
    const getPageButtonProps = (n) => {
      if (!isNaN(+n) && n === currentValue.value) {
        return Object.assign({}, buttonPropsComputed.value, currentPageButtonProps.value);
      }
      return buttonPropsComputed.value;
    };
    const isStandAloneInput = computed(() => props.input && !props.boundaryLinks && !props.directionLinks);
    const inputClassComputed = useBem("va-pagination__input", () => ({
      sm: props.size === "small" && isStandAloneInput.value,
      md: props.size === "medium" && isStandAloneInput.value,
      lg: props.size === "large" && isStandAloneInput.value,
      auto: !isStandAloneInput.value
    }));
    const classComputed = useBem("va-pagination", () => ({
      ...pick(props, ["gapped", "rounded", "disabled"]),
      bordered: !!props.borderColor
    }));
    const goNextPage = () => onUserInput(currentValue.value + 1);
    const goPrevPage = () => onUserInput(currentValue.value - 1);
    const { tp } = useTranslation();
    __expose({
      goNextPage,
      goPrevPage
    });
    return (_ctx, _cache) => {
      return showPagination.value ? (openBlock(), createElementBlock("nav", {
        key: 0,
        class: normalizeClass(["va-pagination", unref(classComputed)]),
        "aria-label": unref(tp)(_ctx.$props.ariaLabel),
        onKeydown: [
          withKeys(withModifiers(goPrevPage, ["stop"]), ["left"]),
          withKeys(withModifiers(goNextPage, ["stop"]), ["right"]),
          withKeys(withModifiers(goPrevPage, ["stop"]), ["up"]),
          withKeys(withModifiers(goNextPage, ["stop"]), ["down"])
        ]
      }, [
        showBoundaryLinks.value ? renderSlot(_ctx.$slots, "firstPageLink", normalizeProps(mergeProps({ key: 0 }, { onClick: () => onUserInput(1), disabled: _ctx.$props.disabled || currentValue.value === 1 })), () => [
          showBoundaryLinks.value ? (openBlock(), createBlock(unref(VaButton), mergeProps({
            key: 0,
            "aria-label": unref(tp)(_ctx.$props.ariaGoToTheFirstPageLabel),
            disabled: _ctx.$props.disabled || currentValue.value === 1,
            icon: _ctx.$props.boundaryIconLeft
          }, buttonPropsComputed.value, {
            onClick: _cache[0] || (_cache[0] = ($event) => onUserInput(1))
          }), null, 16, ["aria-label", "disabled", "icon"])) : createCommentVNode("", true)
        ]) : createCommentVNode("", true),
        showDirectionLinks.value ? renderSlot(_ctx.$slots, "prevPageLink", normalizeProps(mergeProps({ key: 1 }, { onClick: goPrevPage, disabled: _ctx.$props.disabled || currentValue.value === 1 })), () => [
          showDirectionLinks.value ? (openBlock(), createBlock(unref(VaButton), mergeProps({
            key: 0,
            "aria-label": unref(tp)(_ctx.$props.ariaGoToPreviousPageLabel),
            disabled: _ctx.$props.disabled || currentValue.value === 1,
            icon: _ctx.$props.directionIconLeft
          }, buttonPropsComputed.value, { onClick: goPrevPage }), null, 16, ["aria-label", "disabled", "icon"])) : createCommentVNode("", true)
        ]) : createCommentVNode("", true),
        !_ctx.$props.input ? renderSlot(_ctx.$slots, "default", { key: 2 }, () => [
          (openBlock(true), createElementBlock(Fragment, null, renderList(paginationRange.value, (n, i) => {
            return openBlock(), createBlock(unref(VaButton), mergeProps({
              key: i,
              ref_for: true,
              ref: unref(setItemRefByIndex)(i),
              class: { "va-button--ellipsis": n === "...", "va-button--current": n === currentValue.value },
              "aria-label": unref(tp)(_ctx.$props.ariaGoToSpecificPageLabel, { page: n }),
              "aria-current": n === currentValue.value,
              disabled: _ctx.$props.disabled || n === "..."
            }, getPageButtonProps(n), {
              onClick: ($event) => onUserInput(n)
            }), {
              default: withCtx(() => [
                createTextVNode(toDisplayString(n), 1)
              ]),
              _: 2
            }, 1040, ["class", "aria-label", "aria-current", "disabled", "onClick"]);
          }), 128))
        ]) : withDirectives((openBlock(), createElementBlock("input", mergeProps({
          key: 3,
          "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => inputValue.value = $event),
          ref_key: "htmlInput",
          ref: htmlInput,
          class: ["va-pagination__input va-button", unref(inputClassComputed)],
          "aria-label": unref(tp)(_ctx.$props.ariaGoToSpecificPageInputLabel),
          style: inputStyleComputed.value
        }, inputAttributesComputed.value, {
          onKeydown: withKeys(changeValue, ["enter"]),
          onFocus: focusInput,
          onBlur: changeValue
        }), null, 16, _hoisted_2)), [
          [vModelDynamic, inputValue.value]
        ]),
        showDirectionLinks.value ? renderSlot(_ctx.$slots, "nextPageLink", normalizeProps(mergeProps({ key: 4 }, { onClick: goNextPage, disabled: _ctx.$props.disabled || currentValue.value === lastPage.value })), () => [
          showDirectionLinks.value ? (openBlock(), createBlock(unref(VaButton), mergeProps({
            key: 0,
            "aria-label": unref(tp)(_ctx.$props.ariaGoToNextPageLabel),
            disabled: _ctx.$props.disabled || currentValue.value === lastPage.value,
            icon: _ctx.$props.directionIconRight
          }, buttonPropsComputed.value, { onClick: goNextPage }), null, 16, ["aria-label", "disabled", "icon"])) : createCommentVNode("", true)
        ]) : createCommentVNode("", true),
        showBoundaryLinks.value ? renderSlot(_ctx.$slots, "lastPageLink", normalizeProps(mergeProps({ key: 5 }, { onClick: () => onUserInput(lastPage.value), disabled: _ctx.$props.disabled || currentValue.value === lastPage.value })), () => [
          showBoundaryLinks.value ? (openBlock(), createBlock(unref(VaButton), mergeProps({
            key: 0,
            "aria-label": unref(tp)(_ctx.$props.ariaGoToLastPageLabel),
            disabled: _ctx.$props.disabled || currentValue.value === lastPage.value,
            icon: _ctx.$props.boundaryIconRight
          }, buttonPropsComputed.value, {
            onClick: _cache[2] || (_cache[2] = ($event) => onUserInput(lastPage.value))
          }), null, 16, ["aria-label", "disabled", "icon"])) : createCommentVNode("", true)
        ]) : createCommentVNode("", true)
      ], 42, _hoisted_1)) : createCommentVNode("", true);
    };
  }
});
export {
  _sfc_main as _
};
//# sourceMappingURL=VaPagination.vue_vue_type_script_setup_true_lang.js.map
