import { defineComponent, shallowRef, computed, ref, watch, openBlock, createElementBlock, withKeys, withModifiers, Fragment, renderList, unref, toDisplayString, createCommentVNode, createBlock, withCtx, renderSlot, normalizeProps, guardReactiveProps, createVNode, mergeProps } from "vue";
import { p as pick } from "../../../../../vendor.js";
import { s as scrollToElement } from "../../../../utils/scroll-to-element.js";
import { V as VaVirtualScroller } from "../../../va-virtual-scroller/index.js";
import { V as VaSelectOption } from "../VaSelectOption/index.js";
import { i as isNilValue } from "../../../../utils/isNilValue.js";
import { u as unwrapEl } from "../../../../utils/unwrapEl.js";
import { u as useObjectRefs } from "../../../../composables/useObjectRefs.js";
import { a as useColorProps } from "../../../../composables/useColors.js";
import { u as useComponentPresetProp } from "../../../../composables/useComponentPreset.js";
import { u as useSelectableListProps, a as useSelectableList } from "../../../../composables/useSelectableList.js";
import { u as useThrottleProps, a as useThrottleValue } from "../../../../composables/useThrottle.js";
import { u as useNumericProp } from "../../../../composables/useNumericProp.js";
const _hoisted_1 = ["tabindex", "onKeydown", "aria-multiselectable"];
const _hoisted_2 = {
  key: 0,
  class: "va-select-option-list__group-name",
  role: "presentation"
};
const _hoisted_3 = {
  key: 0,
  class: "va-select-option-list--empty"
};
const _sfc_main = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaSelectOptionList"
  },
  __name: "VaSelectOptionList",
  props: {
    ...useColorProps,
    ...useComponentPresetProp,
    ...useSelectableListProps,
    ...useThrottleProps,
    noOptionsText: { type: String, default: "Items not found" },
    getSelectedState: { type: Function, required: true },
    multiple: { type: Boolean, default: false },
    search: { type: String, default: "" },
    tabindex: { type: [String, Number], default: 0 },
    hoveredOption: { type: [String, Number, Boolean, Object], default: null },
    virtualScroller: { type: Boolean, default: true },
    highlightMatchedText: { type: Boolean, default: true },
    minSearchChars: { type: [Number, String], default: 0 },
    autoSelectFirstOption: { type: Boolean, default: false },
    selectedTopShown: { type: Boolean, default: false },
    doShowAllOptions: { type: Boolean, default: false }
  },
  emits: [
    "select-option",
    "update:hoveredOption",
    "no-previous-option-to-hover",
    "scroll-bottom"
  ],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const root = shallowRef();
    const focus = () => {
      var _a;
      (_a = root.value) == null ? void 0 : _a.focus({ preventScroll: true });
    };
    const rootHeight = computed(() => {
      var _a;
      return ((_a = root.value) == null ? void 0 : _a.clientHeight) ?? 200;
    });
    const handleScrollToBottom = () => emit("scroll-bottom");
    const onScroll = (event) => {
      const target = event.target;
      if (!target) {
        return;
      }
      if (target.scrollTop + target.clientHeight === target.scrollHeight) {
        handleScrollToBottom();
      }
    };
    const lastInteractionSource = ref("");
    const currentOptionComputed = computed(() => props.hoveredOption ?? null);
    const updateCurrentOption = (option, source) => {
      emit("update:hoveredOption", option);
      lastInteractionSource.value = source;
    };
    const { getText, getGroupBy, getTrackBy, getDisabled } = useSelectableList(props);
    const minSearchCharsComputed = useNumericProp("minSearchChars");
    const currentSelectedOptionText = computed(() => {
      var _a;
      const getSelectedState = props.getSelectedState;
      const selected = (_a = props.options) == null ? void 0 : _a.find((option) => getSelectedState(option));
      return selected ? getText(selected) : "";
    });
    const isSearchedOptionSelected = computed(() => {
      var _a;
      return currentSelectedOptionText.value.toLowerCase() === ((_a = props.search) == null ? void 0 : _a.toLowerCase());
    });
    const filteredOptions = computed(() => {
      if (props.doShowAllOptions && isSearchedOptionSelected.value) {
        return props.options;
      }
      if (!props.search || props.search.length < minSearchCharsComputed.value) {
        return props.options;
      }
      const search = props.search.toUpperCase().trim();
      return props.options.filter((option) => {
        const optionText = getText(option).toUpperCase();
        return optionText.includes(search);
      });
    });
    const optionGroups = computed(() => {
      if (!props.groupBy) {
        return { _noGroup: filteredOptions.value };
      }
      return filteredOptions.value.reduce((groups, option) => {
        const groupBy = getGroupBy(option);
        if (!groupBy) {
          groups._noGroup.push(option);
        } else {
          if (!groups[groupBy]) {
            groups[groupBy] = [];
          }
          groups[groupBy].push(option);
        }
        return groups;
      }, { _noGroup: [] });
    });
    const optionGroupsThrottled = useThrottleValue(optionGroups, props);
    const isValueExists = (value) => !isNilValue(value);
    const updateHoveredOption = (option) => {
      if (option === currentOptionComputed.value || isValueExists(option) && getDisabled(option)) {
        return;
      }
      updateCurrentOption(option ?? null, "mouse");
    };
    const updateFocusedOption = (option) => {
      updateCurrentOption(option ?? null, "keyboard");
    };
    const selectHoveredOption = () => {
      const previousOption = previousOptionComputed.value && typeof previousOptionComputed.value === "object" ? { ...previousOptionComputed.value } : previousOptionComputed.value;
      emit("select-option");
      if (props.selectedTopShown) {
        updateHoveredOption(previousOption);
      }
    };
    const groupedOptions = computed(() => Object.values(optionGroupsThrottled.value).flat());
    const currentOptions = computed(() => filteredOptions.value.some((el) => getGroupBy(el)) ? groupedOptions.value : filteredOptions.value);
    const currentOptionIndex = computed(() => currentOptions.value.findIndex((option) => {
      return isValueExists(currentOptionComputed.value) && getTrackBy(option) === getTrackBy(currentOptionComputed.value);
    }));
    const selectOptionProps = computed(() => ({
      ...pick(props, ["getSelectedState", "color", "search", "highlightMatchedText"]),
      minSearchChars: minSearchCharsComputed.value,
      getText,
      getTrackBy
    }));
    const findNextActiveOption = (startSearchIndex, reversedSearch = false) => {
      const searchBase = [...currentOptions.value || []];
      const searchBaseOrdered = reversedSearch ? searchBase.reverse() : searchBase;
      const startIndex = reversedSearch ? startSearchIndex * -1 - 1 : startSearchIndex;
      return searchBaseOrdered.slice(startIndex).find((option) => !getDisabled(option));
    };
    const previousOptionComputed = computed(() => {
      const previousOptionIndex = currentOptionIndex.value - 1;
      const previousOption = currentOptions.value[previousOptionIndex];
      const previousOptionCheck = isValueExists(previousOption) && !(previousOptionIndex === 0 && getDisabled(previousOption));
      if (previousOptionCheck) {
        return findNextActiveOption(currentOptionIndex.value - 1, true);
      }
      return void 0;
    });
    const selectOption = (option) => {
      updateHoveredOption(option);
      emit("select-option");
    };
    const handleMouseMove = (option) => {
      if (!props.selectedTopShown) {
        updateHoveredOption(option);
      }
    };
    const handleMouseEnter = (option) => {
      if (props.selectedTopShown) {
        updateHoveredOption(option);
      }
    };
    const focusPreviousOption = () => {
      if (!isValueExists(currentOptionComputed.value)) {
        updateFocusedOption(findNextActiveOption(0, true));
        return;
      }
      if (isValueExists(previousOptionComputed.value)) {
        updateFocusedOption(previousOptionComputed.value);
      } else {
        emit("no-previous-option-to-hover");
      }
    };
    const focusNextOption = () => {
      if (!isValueExists(currentOptionComputed.value)) {
        focusFirstOption();
        return;
      }
      const nextOptionIndex = currentOptionIndex.value + 1;
      const nextOption = currentOptions.value[nextOptionIndex];
      const nextOptionCheck = isValueExists(nextOption) && !(nextOptionIndex === currentOptions.value.length - 1 && getDisabled(nextOption));
      if (nextOptionCheck) {
        updateFocusedOption(findNextActiveOption(currentOptionIndex.value + 1));
      }
    };
    const focusFirstOption = () => updateFocusedOption(findNextActiveOption(0));
    const { itemRefs, setItemRef } = useObjectRefs();
    const virtualScrollerRef = shallowRef();
    const scrollToOption = (option) => {
      var _a;
      if (!isValueExists(option)) {
        return;
      }
      const element = unwrapEl(itemRefs.value[getTrackBy(option)]);
      if (element) {
        scrollToElement(element);
      }
      const virtualScroller = (_a = virtualScrollerRef.value) == null ? void 0 : _a[0];
      if (props.virtualScroller) {
        virtualScroller.virtualScrollTo(currentOptionIndex.value);
      }
    };
    watch(() => props.hoveredOption, (newOption) => {
      (!lastInteractionSource.value || lastInteractionSource.value === "keyboard") && isValueExists(newOption) && scrollToOption(newOption);
    });
    watch(filteredOptions, () => {
      if (!props.autoSelectFirstOption) {
        return;
      }
      focusFirstOption();
    }, { immediate: true });
    __expose({
      focusPreviousOption,
      focusNextOption,
      focusFirstOption,
      scrollToOption,
      focus
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        ref_key: "root",
        ref: root,
        class: "va-select-option-list",
        tabindex: __props.tabindex,
        onKeydown: [
          withKeys(withModifiers(focusPreviousOption, ["stop", "prevent"]), ["up"]),
          withKeys(withModifiers(focusPreviousOption, ["stop", "prevent"]), ["left"]),
          withKeys(withModifiers(focusNextOption, ["stop", "prevent"]), ["down"]),
          withKeys(withModifiers(focusNextOption, ["stop", "prevent"]), ["right"]),
          withKeys(withModifiers(selectHoveredOption, ["stop", "prevent"]), ["enter"]),
          withKeys(withModifiers(selectHoveredOption, ["stop", "prevent"]), ["space"])
        ],
        onScrollPassive: onScroll,
        role: "listbox",
        "aria-multiselectable": _ctx.$props.multiple
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(unref(optionGroupsThrottled), (options, groupName) => {
          return openBlock(), createElementBlock(Fragment, { key: groupName }, [
            groupName !== "_noGroup" ? (openBlock(), createElementBlock("span", _hoisted_2, toDisplayString(groupName), 1)) : createCommentVNode("", true),
            _ctx.$props.virtualScroller ? (openBlock(), createBlock(unref(VaVirtualScroller), {
              key: 1,
              ref_for: true,
              ref_key: "virtualScrollerRef",
              ref: virtualScrollerRef,
              items: options,
              "track-by": unref(getTrackBy),
              "wrapper-size": rootHeight.value,
              "onScroll:bottom": handleScrollToBottom
            }, {
              default: withCtx(({ item: option, index }) => [
                renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps({ option, index, selectOption: (o = option) => selectOption(o) })), () => [
                  createVNode(unref(VaSelectOption), mergeProps({
                    option,
                    "current-option": currentOptionComputed.value,
                    disabled: unref(getDisabled)(option)
                  }, selectOptionProps.value, {
                    onClick: withModifiers(selectHoveredOption, ["stop"]),
                    onMouseenter: ($event) => handleMouseEnter(option),
                    onMousemove: ($event) => handleMouseMove(option)
                  }), null, 16, ["option", "current-option", "disabled", "onMouseenter", "onMousemove"])
                ])
              ]),
              _: 2
            }, 1032, ["items", "track-by", "wrapper-size"])) : (openBlock(true), createElementBlock(Fragment, { key: 2 }, renderList(options, (option, index) => {
              return renderSlot(_ctx.$slots, "default", normalizeProps(mergeProps({
                key: unref(getTrackBy)(option)
              }, { option, index, selectOption })), () => [
                createVNode(unref(VaSelectOption), mergeProps({
                  ref_for: true,
                  ref: unref(setItemRef)(unref(getTrackBy)(option)),
                  "current-option": currentOptionComputed.value,
                  option,
                  disabled: unref(getDisabled)(option)
                }, selectOptionProps.value, {
                  onClick: withModifiers(selectHoveredOption, ["stop"]),
                  onMouseenter: ($event) => handleMouseEnter(option),
                  onMousemove: ($event) => handleMouseMove(option)
                }), {
                  "option-content": withCtx(() => [
                    renderSlot(_ctx.$slots, "option-content", normalizeProps(guardReactiveProps({ option, index })))
                  ]),
                  _: 2
                }, 1040, ["current-option", "option", "disabled", "onMouseenter", "onMousemove"])
              ]);
            }), 128))
          ], 64);
        }), 128)),
        !filteredOptions.value.length ? (openBlock(), createElementBlock("div", _hoisted_3, toDisplayString(__props.noOptionsText), 1)) : createCommentVNode("", true)
      ], 40, _hoisted_1);
    };
  }
});
export {
  _sfc_main as _
};
//# sourceMappingURL=VaSelectOptionList.vue_vue_type_script_setup_true_lang.js.map
