import { defineComponent, toRef, computed, openBlock, createBlock, resolveDynamicComponent, unref, mergeProps, toHandlers, withCtx, renderSlot } from "vue";
import { a as useSidebarItem } from "../hooks/useSidebar.js";
import { u as useComponentPresetProp } from "../../../composables/useComponentPreset.js";
import { e as applyColors } from "../../../services/color/utils.js";
import { u as useRouterLinkProps, a as useRouterLink } from "../../../composables/useRouterLink.js";
import { u as useElementRef } from "../../../composables/useElementRef.js";
import { u as useHover } from "../../../composables/useHover.js";
import { u as useColors } from "../../../composables/useColors.js";
import { u as useKeyboardOnlyFocus } from "../../../composables/useKeyboardOnlyFocus.js";
import { u as useTextColor } from "../../../composables/useTextColor.js";
const _sfc_main = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaSidebarItem"
  },
  __name: "VaSidebarItem",
  props: {
    ...useRouterLinkProps,
    ...useComponentPresetProp,
    active: { type: Boolean, default: false },
    textColor: { type: String, default: void 0 },
    activeColor: { type: String, default: "primary" },
    hoverColor: { type: String, default: void 0 },
    hoverOpacity: { type: [Number, String], default: 0.2 },
    borderColor: { type: String, default: void 0 },
    disabled: { type: Boolean, default: false }
  },
  setup(__props) {
    const props = __props;
    const rootElement = useElementRef();
    const sidebar = useSidebarItem();
    const { isHovered } = useHover(rootElement, toRef(props, "disabled"));
    const { getColor, getHoverColor, getFocusColor } = useColors();
    const { hasKeyboardFocus, keyboardFocusListeners } = useKeyboardOnlyFocus();
    const backgroundColorComputed = computed(() => {
      if (props.active && !isHovered.value && !hasKeyboardFocus.value) {
        return getColor(props.activeColor);
      }
      if (hasKeyboardFocus.value) {
        return getFocusColor(getColor(props.hoverColor || props.activeColor));
      }
      return "#ffffff00";
    });
    const textBackground = computed(() => applyColors(getColor(sidebar == null ? void 0 : sidebar.color), backgroundColorComputed.value));
    const { textColorComputed } = useTextColor(textBackground);
    const computedStyle = computed(() => {
      const style = { color: textColorComputed.value };
      if (props.disabled) {
        return style;
      }
      if (isHovered.value || props.active || hasKeyboardFocus.value) {
        style.backgroundColor = backgroundColorComputed.value;
      }
      if (props.active) {
        const mergedProps = { ...sidebar, ...props };
        style.borderColor = getColor(mergedProps.borderColor || mergedProps.activeColor);
      }
      if (hasKeyboardFocus.value) {
        style.backgroundColor = getFocusColor(getColor(props.hoverColor || props.activeColor));
      }
      if (isHovered.value) {
        style.backgroundColor = getHoverColor(
          getColor(props.hoverColor || props.activeColor),
          Number(props.hoverOpacity)
        );
      }
      return style;
    });
    const { tagComputed, linkAttributesComputed } = useRouterLink(props);
    return (_ctx, _cache) => {
      return openBlock(), createBlock(resolveDynamicComponent(unref(tagComputed)), mergeProps({
        ref_key: "rootElement",
        ref: rootElement,
        class: ["va-sidebar__item va-sidebar-item", {
          "va-sidebar-item--active": _ctx.$props.active,
          "va-sidebar-item--disabled": _ctx.$props.disabled
        }],
        tabindex: _ctx.$props.disabled ? -1 : 0,
        style: computedStyle.value
      }, unref(linkAttributesComputed), toHandlers(unref(keyboardFocusListeners))), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16, ["tabindex", "class", "style"]);
    };
  }
});
export {
  _sfc_main as _
};
//# sourceMappingURL=VaSidebarItem.vue_vue_type_script_setup_true_lang.js.map
